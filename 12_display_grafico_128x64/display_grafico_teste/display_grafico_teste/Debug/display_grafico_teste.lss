
display_grafico_teste.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000028  00800100  000020ac  00002120  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000020ac  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      00000030  00000000  00000000  00002148  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002178  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 000000a8  00000000  00000000  000021b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000017ab  00000000  00000000  00002260  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000008ec  00000000  00000000  00003a0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000a6b  00000000  00000000  000042f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000208  00000000  00000000  00004d64  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000058c  00000000  00000000  00004f6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000119a  00000000  00000000  000054f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000e8  00000000  00000000  00006692  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 0d 	jmp	0x1a6e	; 0x1a6e <__ctors_end>
       4:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
       8:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
       c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      10:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      14:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      18:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      1c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      20:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      24:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      28:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      2c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      30:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      34:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      38:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      3c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      40:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      44:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      48:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      4c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      50:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      54:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      58:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      5c:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      60:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>
      64:	0c 94 4c 0d 	jmp	0x1a98	; 0x1a98 <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	00 00       	nop
      6a:	00 00       	nop
      6c:	00 00       	nop
      6e:	00 5f       	subi	r16, 0xF0	; 240
      70:	00 00       	nop
      72:	00 07       	cpc	r16, r16
      74:	00 07       	cpc	r16, r16
      76:	00 14       	cp	r0, r0
      78:	7f 14       	cp	r7, r15
      7a:	7f 14       	cp	r7, r15
      7c:	24 2a       	or	r2, r20
      7e:	7f 2a       	or	r7, r31
      80:	12 23       	and	r17, r18
      82:	13 08       	sbc	r1, r3
      84:	64 62       	ori	r22, 0x24	; 36
      86:	36 49       	sbci	r19, 0x96	; 150
      88:	55 22       	and	r5, r21
      8a:	50 00       	.word	0x0050	; ????
      8c:	05 03       	mulsu	r16, r21
      8e:	00 00       	nop
      90:	00 1c       	adc	r0, r0
      92:	22 41       	sbci	r18, 0x12	; 18
      94:	00 00       	nop
      96:	41 22       	and	r4, r17
      98:	1c 00       	.word	0x001c	; ????
      9a:	14 08       	sbc	r1, r4
      9c:	3e 08       	sbc	r3, r14
      9e:	14 08       	sbc	r1, r4
      a0:	08 3e       	cpi	r16, 0xE8	; 232
      a2:	08 08       	sbc	r0, r8
      a4:	00 50       	subi	r16, 0x00	; 0
      a6:	30 00       	.word	0x0030	; ????
      a8:	00 08       	sbc	r0, r0
      aa:	08 08       	sbc	r0, r8
      ac:	08 08       	sbc	r0, r8
      ae:	00 60       	ori	r16, 0x00	; 0
      b0:	60 00       	.word	0x0060	; ????
      b2:	00 20       	and	r0, r0
      b4:	10 08       	sbc	r1, r0
      b6:	04 02       	muls	r16, r20
      b8:	3e 51       	subi	r19, 0x1E	; 30
      ba:	49 45       	sbci	r20, 0x59	; 89
      bc:	3e 00       	.word	0x003e	; ????
      be:	42 7f       	andi	r20, 0xF2	; 242
      c0:	40 00       	.word	0x0040	; ????
      c2:	42 61       	ori	r20, 0x12	; 18
      c4:	51 49       	sbci	r21, 0x91	; 145
      c6:	46 21       	and	r20, r6
      c8:	41 45       	sbci	r20, 0x51	; 81
      ca:	4b 31       	cpi	r20, 0x1B	; 27
      cc:	18 14       	cp	r1, r8
      ce:	12 7f       	andi	r17, 0xF2	; 242
      d0:	10 27       	eor	r17, r16
      d2:	45 45       	sbci	r20, 0x55	; 85
      d4:	45 39       	cpi	r20, 0x95	; 149
      d6:	3c 4a       	sbci	r19, 0xAC	; 172
      d8:	49 49       	sbci	r20, 0x99	; 153
      da:	30 01       	movw	r6, r0
      dc:	01 79       	andi	r16, 0x91	; 145
      de:	05 03       	mulsu	r16, r21
      e0:	36 49       	sbci	r19, 0x96	; 150
      e2:	49 49       	sbci	r20, 0x99	; 153
      e4:	36 06       	cpc	r3, r22
      e6:	49 49       	sbci	r20, 0x99	; 153
      e8:	29 1e       	adc	r2, r25
      ea:	00 36       	cpi	r16, 0x60	; 96
      ec:	36 00       	.word	0x0036	; ????
      ee:	00 00       	nop
      f0:	56 36       	cpi	r21, 0x66	; 102
      f2:	00 00       	nop
      f4:	08 14       	cp	r0, r8
      f6:	22 41       	sbci	r18, 0x12	; 18
      f8:	00 14       	cp	r0, r0
      fa:	14 14       	cp	r1, r4
      fc:	14 14       	cp	r1, r4
      fe:	41 22       	and	r4, r17
     100:	14 08       	sbc	r1, r4
     102:	00 02       	muls	r16, r16
     104:	01 51       	subi	r16, 0x11	; 17
     106:	09 06       	cpc	r0, r25
     108:	3e 41       	sbci	r19, 0x1E	; 30
     10a:	5d 55       	subi	r21, 0x5D	; 93
     10c:	5e 7e       	andi	r21, 0xEE	; 238
     10e:	09 09       	sbc	r16, r9
     110:	09 7e       	andi	r16, 0xE9	; 233
     112:	7f 49       	sbci	r23, 0x9F	; 159
     114:	49 49       	sbci	r20, 0x99	; 153
     116:	36 3e       	cpi	r19, 0xE6	; 230
     118:	41 41       	sbci	r20, 0x11	; 17
     11a:	41 22       	and	r4, r17
     11c:	7f 41       	sbci	r23, 0x1F	; 31
     11e:	41 22       	and	r4, r17
     120:	1c 7f       	andi	r17, 0xFC	; 252
     122:	49 49       	sbci	r20, 0x99	; 153
     124:	41 41       	sbci	r20, 0x11	; 17
     126:	7f 09       	sbc	r23, r15
     128:	09 09       	sbc	r16, r9
     12a:	01 3e       	cpi	r16, 0xE1	; 225
     12c:	41 41       	sbci	r20, 0x11	; 17
     12e:	49 7a       	andi	r20, 0xA9	; 169
     130:	7f 08       	sbc	r7, r15
     132:	08 08       	sbc	r0, r8
     134:	7f 00       	.word	0x007f	; ????
     136:	41 7f       	andi	r20, 0xF1	; 241
     138:	41 00       	.word	0x0041	; ????
     13a:	20 40       	sbci	r18, 0x00	; 0
     13c:	41 3f       	cpi	r20, 0xF1	; 241
     13e:	01 7f       	andi	r16, 0xF1	; 241
     140:	08 14       	cp	r0, r8
     142:	22 41       	sbci	r18, 0x12	; 18
     144:	7f 40       	sbci	r23, 0x0F	; 15
     146:	40 40       	sbci	r20, 0x00	; 0
     148:	40 7f       	andi	r20, 0xF0	; 240
     14a:	02 0c       	add	r0, r2
     14c:	02 7f       	andi	r16, 0xF2	; 242
     14e:	7f 04       	cpc	r7, r15
     150:	08 10       	cpse	r0, r8
     152:	7f 3e       	cpi	r23, 0xEF	; 239
     154:	41 41       	sbci	r20, 0x11	; 17
     156:	41 3e       	cpi	r20, 0xE1	; 225
     158:	7f 09       	sbc	r23, r15
     15a:	09 09       	sbc	r16, r9
     15c:	06 3e       	cpi	r16, 0xE6	; 230
     15e:	41 51       	subi	r20, 0x11	; 17
     160:	21 5e       	subi	r18, 0xE1	; 225
     162:	7f 09       	sbc	r23, r15
     164:	19 29       	or	r17, r9
     166:	46 46       	sbci	r20, 0x66	; 102
     168:	49 49       	sbci	r20, 0x99	; 153
     16a:	49 31       	cpi	r20, 0x19	; 25
     16c:	01 01       	movw	r0, r2
     16e:	7f 01       	movw	r14, r30
     170:	01 3f       	cpi	r16, 0xF1	; 241
     172:	40 40       	sbci	r20, 0x00	; 0
     174:	40 3f       	cpi	r20, 0xF0	; 240
     176:	1f 20       	and	r1, r15
     178:	40 20       	and	r4, r0
     17a:	1f 3f       	cpi	r17, 0xFF	; 255
     17c:	40 3f       	cpi	r20, 0xF0	; 240
     17e:	40 3f       	cpi	r20, 0xF0	; 240
     180:	63 14       	cp	r6, r3
     182:	08 14       	cp	r0, r8
     184:	63 07       	cpc	r22, r19
     186:	08 78       	andi	r16, 0x88	; 136
     188:	08 07       	cpc	r16, r24
     18a:	61 51       	subi	r22, 0x11	; 17
     18c:	49 45       	sbci	r20, 0x59	; 89
     18e:	43 00       	.word	0x0043	; ????
     190:	7f 41       	sbci	r23, 0x1F	; 31
     192:	41 00       	.word	0x0041	; ????
     194:	01 02       	muls	r16, r17
     196:	04 08       	sbc	r0, r4
     198:	10 00       	.word	0x0010	; ????
     19a:	41 41       	sbci	r20, 0x11	; 17
     19c:	7f 00       	.word	0x007f	; ????
     19e:	04 02       	muls	r16, r20
     1a0:	01 02       	muls	r16, r17
     1a2:	04 40       	sbci	r16, 0x04	; 4
     1a4:	40 40       	sbci	r20, 0x00	; 0
     1a6:	40 40       	sbci	r20, 0x00	; 0
     1a8:	00 00       	nop
     1aa:	03 05       	cpc	r16, r3
     1ac:	00 20       	and	r0, r0
     1ae:	54 54       	subi	r21, 0x44	; 68
     1b0:	54 78       	andi	r21, 0x84	; 132
     1b2:	7f 48       	sbci	r23, 0x8F	; 143
     1b4:	44 44       	sbci	r20, 0x44	; 68
     1b6:	38 38       	cpi	r19, 0x88	; 136
     1b8:	44 44       	sbci	r20, 0x44	; 68
     1ba:	44 20       	and	r4, r4
     1bc:	38 44       	sbci	r19, 0x48	; 72
     1be:	44 48       	sbci	r20, 0x84	; 132
     1c0:	7f 38       	cpi	r23, 0x8F	; 143
     1c2:	54 54       	subi	r21, 0x44	; 68
     1c4:	54 18       	sub	r5, r4
     1c6:	08 7e       	andi	r16, 0xE8	; 232
     1c8:	09 01       	movw	r0, r18
     1ca:	02 08       	sbc	r0, r2
     1cc:	54 54       	subi	r21, 0x44	; 68
     1ce:	54 3c       	cpi	r21, 0xC4	; 196
     1d0:	7f 08       	sbc	r7, r15
     1d2:	04 04       	cpc	r0, r4
     1d4:	78 00       	.word	0x0078	; ????
     1d6:	44 7d       	andi	r20, 0xD4	; 212
     1d8:	40 00       	.word	0x0040	; ????
     1da:	20 40       	sbci	r18, 0x00	; 0
     1dc:	45 3c       	cpi	r20, 0xC5	; 197
     1de:	00 7f       	andi	r16, 0xF0	; 240
     1e0:	10 28       	or	r1, r0
     1e2:	44 00       	.word	0x0044	; ????
     1e4:	00 41       	sbci	r16, 0x10	; 16
     1e6:	7f 40       	sbci	r23, 0x0F	; 15
     1e8:	00 7c       	andi	r16, 0xC0	; 192
     1ea:	04 38       	cpi	r16, 0x84	; 132
     1ec:	04 78       	andi	r16, 0x84	; 132
     1ee:	7c 08       	sbc	r7, r12
     1f0:	04 04       	cpc	r0, r4
     1f2:	78 38       	cpi	r23, 0x88	; 136
     1f4:	44 44       	sbci	r20, 0x44	; 68
     1f6:	44 38       	cpi	r20, 0x84	; 132
     1f8:	7c 14       	cp	r7, r12
     1fa:	14 14       	cp	r1, r4
     1fc:	08 08       	sbc	r0, r8
     1fe:	14 14       	cp	r1, r4
     200:	18 7c       	andi	r17, 0xC8	; 200
     202:	7c 08       	sbc	r7, r12
     204:	04 04       	cpc	r0, r4
     206:	08 48       	sbci	r16, 0x88	; 136
     208:	54 54       	subi	r21, 0x44	; 68
     20a:	54 20       	and	r5, r4
     20c:	04 3f       	cpi	r16, 0xF4	; 244
     20e:	44 40       	sbci	r20, 0x04	; 4
     210:	20 3c       	cpi	r18, 0xC0	; 192
     212:	40 40       	sbci	r20, 0x00	; 0
     214:	20 7c       	andi	r18, 0xC0	; 192
     216:	1c 20       	and	r1, r12
     218:	40 20       	and	r4, r0
     21a:	1c 3c       	cpi	r17, 0xCC	; 204
     21c:	40 3c       	cpi	r20, 0xC0	; 192
     21e:	40 3c       	cpi	r20, 0xC0	; 192
     220:	44 28       	or	r4, r4
     222:	10 28       	or	r1, r0
     224:	44 0c       	add	r4, r4
     226:	50 50       	subi	r21, 0x00	; 0
     228:	50 3c       	cpi	r21, 0xC0	; 192
     22a:	44 64       	ori	r20, 0x44	; 68
     22c:	54 4c       	sbci	r21, 0xC4	; 196
     22e:	44 00       	.word	0x0044	; ????
     230:	08 36       	cpi	r16, 0x68	; 104
     232:	41 00       	.word	0x0041	; ????
     234:	00 00       	nop
     236:	7f 00       	.word	0x007f	; ????
     238:	00 00       	nop
     23a:	41 36       	cpi	r20, 0x61	; 97
     23c:	08 00       	.word	0x0008	; ????
     23e:	10 08       	sbc	r1, r0
     240:	10 20       	and	r1, r0
     242:	10 6d       	Address 0x00000242 is out of bounds.
.word	0xffff	; ????

00000243 <str_memprog>:
     243:	6d 65 6d 6f 72 69 61 20 64 65 20 70 72 6f 67 72     memoria de progr
     253:	61 6d 61 21 00 00                                   ama!..

00000259 <teste_memprog>:
     259:	54 65 73 74 65 21 00 00                             Teste!..

00000261 <p_ryu>:
     261:	6d 16 6d 12 6d 0e 6d 0a 6d 06 6d 02                 m.m.m.m.m.m.

0000026d <ryu5>:
	...
     2ad:	00 00 20 60 60 10 d0 90 10 10 30 30 20 60 60 40     .. ``.....00 ``@
     2bd:	80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     309:	80 60 60 20 20 60 20 f8 fc 3c 7e 7e fc fc f8 f8     .``  ` ..<~~....
     319:	e0 00 00 00 00 00 80 c0 c0 40 80 00 00 00 00 00     .........@......
     329:	00 00 00 00 0c 0c 0c 1e 36 32 d3 d1 00 00 00 00     ........62......
     339:	00 00 00 00 01 03 07 0e 38 f0 c0 00 00 00 00 00     ........8.......
	...
     385:	00 00 ff c3 00 fe 83 01 81 c1 c0 e0 45 47 80 84     ............EG..
     395:	8d 3f 3f 1b 0c 24 24 74 f8 ff 67 4b 47 3e 01 00     .??..$$t..gKG>..
     3a5:	00 00 00 00 80 c0 c0 c0 40 40 40 46 46 69 39 d8     ........@@@FFi9.
     3b5:	80 00 00 00 00 00 00 00 00 00 00 00 00 00 0f f8     ................
	...
     405:	00 88 37 e1 c0 00 03 06 07 03 01 01 01 03 01 03     ..7.............
     415:	ff c4 3d 09 08 0c 08 0f ff ff e1 7b f0 13 ce 00     ..=........{....
     425:	00 00 00 00 01 01 01 01 03 03 23 23 2a 52 de 8d     ..........##*R..
	...
     441:	00 80 f8 1f 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     47d:	00 00 00 80 c0 70 1a 0f 07 62 40 82 05 0b 17 96     .....p...b@.....
     48d:	fe fe fc fc 4e 6f 12 03 09 04 08 08 10 30 40 c0     ....No.......0@.
     49d:	80 01 01 01 01 00 00 00 00 00 00 00 00 00 00 00     ................
     4ad:	18 18 18 28 2e 6e e7 c1 00 00 00 00 00 00 00 00     ...(.n..........
     4bd:	80 c0 60 38 0e 07 01 00 00 00 00 00 00 00 00 00     ..`8............
	...
     4f9:	00 e0 20 10 18 1c 3c 07 01 00 00 00 80 e0 70 30     .. ...<.......p0
     509:	18 1d 0d 1f ff ff ff 7f 14 12 3a f8 68 00 00 00     ..........:.h...
     519:	00 00 00 f0 1f 00 00 00 00 00 00 00 00 00 00 00     ................
     529:	00 00 00 00 00 00 02 02 02 05 05 04 04 04 04 04     ................
     539:	06 02 03 01 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     571:	00 00 80 f8 6c 02 00 7e c3 80 00 00 80 c0 60 30     ....l..~......`0
     581:	18 0e 06 03 01 00 00 00 00 00 00 00 00 00 00 00     ................
     591:	00 00 9f ff e0 60 20 f0 70 00 08 0f 00 00 00 00     .....` .p.......
	...
     5ed:	30 78 78 7c fc fc ff ff f0 f0 f0 fc 76 7f 7f 7f     0xx|........v...
     5fd:	7f 7f 7f 7e 7e fe fc fc fe fc fc fc fc fc fc fc     ...~~...........
     60d:	fc fc fc fc fc fc ff f9 f0 f8 f0 f1 f2 f6 f2 7c     ...............|
     61d:	7c 78 30 00 00 00 00 00 00 00 00 00 00 00 00 00     |x0.............
	...

0000066d <ryu4>:
	...
     709:	80 60 60 20 20 60 20 f8 fc 3c 7e 7e fc fc f8 f8     .``  ` ..<~~....
     719:	e0 00 00 00 00 00 80 c0 c0 c0 20 20 18 18 18 18     ..........  ....
     729:	18 18 18 30 20 60 c0 80 00 00 00 00 00 00 00 00     ...0 `..........
	...
     785:	00 00 ff c3 00 fe 83 01 81 c1 c0 e0 45 47 80 84     ............EG..
     795:	8d 3f 3f 1b 0c 24 24 e4 f8 3f 0f 01 00 00 00 00     .??..$$..?......
     7a5:	20 e0 f8 c4 84 05 09 1f 08 00 00 01 03 06 f8 00      ...............
	...
     805:	00 88 37 e1 c0 00 03 06 07 03 01 01 01 03 01 03     ..7.............
     815:	ff c4 3d 09 08 0c 08 0f ff f8 e0 80 00 00 00 00     ..=.............
     825:	0d 0f 1f 07 42 02 20 f0 00 00 00 00 80 e0 3f 00     ....B. .......?.
	...
     87d:	00 00 00 80 c0 70 1a 0f 07 62 40 82 05 0b 17 96     .....p...b@.....
     88d:	fe fe fc fc 4e 6f 12 03 09 04 08 08 10 30 40 c0     ....No.......0@.
     89d:	80 01 01 01 03 06 0c 1c 10 10 10 10 10 10 18 18     ................
     8ad:	08 0c 06 03 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     8f9:	00 e0 20 10 18 1c 3c 07 01 00 00 00 80 e0 70 38     .. ...<.......p8
     909:	18 1d 0d 1f ff ff ff 7f 14 12 3a f8 68 00 00 00     ..........:.h...
     919:	00 00 00 f0 1f 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     971:	00 00 80 f8 6c 02 00 7e c3 80 00 00 80 c0 60 30     ....l..~......`0
     981:	18 0e 06 03 01 00 00 00 00 00 00 00 00 00 00 00     ................
     991:	00 00 9f ff e0 60 20 f0 f0 00 08 0f 00 00 00 00     .....` .........
	...
     9ed:	30 78 78 7c fc fc ff ff f0 f0 f0 fc 76 7f 7f 7f     0xx|........v...
     9fd:	7f 7f 7f 7e 7e fe fc fc fe fc fc fc fc fc fc fc     ...~~...........
     a0d:	fc fc fc fc fc fc ff f9 f0 f8 f0 f1 f2 f6 f2 7c     ...............|
     a1d:	7c 78 30 00 00 00 00 00 00 00 00 00 00 00 00 00     |x0.............
	...

00000a6d <ryu3>:
	...
     a81:	00 c0 00 c0 00 80 80 80 80 00 00 00 00 00 00 00     ................
	...
     afd:	00 40 b0 f0 28 13 06 bf ef df 1f 7f 7f ff 7e fe     .@..(.........~.
     b0d:	3c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     <...............
	...
     b79:	00 00 00 c0 e0 90 9f c1 fc a2 1b 45 24 13 8e c5     ...........E$...
     b89:	65 22 22 21 e0 02 e4 f0 00 00 00 00 00 00 00 00     e""!............
	...
     bf9:	00 00 00 3f f1 eb fd ff fc 9f 1c 08 18 37 63 c1     ...?.........7c.
     c09:	c0 20 3c ce 27 18 05 03 00 00 00 00 00 00 00 00     . <.'...........
	...
     c79:	00 06 f8 bf c3 e7 68 b1 f1 fb 7f 5f de ca cb 43     ......h...._...C
     c89:	23 11 09 0d 03 0e 08 10 30 60 c0 80 00 00 00 00     #.......0`......
	...
     cf5:	00 00 80 c0 70 3f 0f 00 02 02 07 03 81 78 1e 07     ....p?.......x..
     d05:	0d 0c 18 18 10 10 78 f8 d4 08 20 00 00 00 00 0f     ......x... .....
     d15:	30 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00     0...............
	...
     d71:	00 00 00 80 f8 7f 83 80 00 00 00 80 c0 bc 8c 86     ................
     d81:	83 80 80 00 00 00 00 00 00 00 00 03 06 7e 60 00     .............~`.
     d91:	c0 e0 60 10 49 8d 00 00 00 00 00 00 00 00 00 00     ..`.I...........
	...
     ded:	18 3c 3c 7c 7c 7c 7f 7f 7e 7c 78 70 3f 33 3f 3f     .<<|||..~|xp?3??
     dfd:	3f 3f 3f 3f 3f 3f 3f 3f 7f 7e 7e 7e 7e 7c 7c 7c     ????????.~~~~|||
     e0d:	7c 7c 7c 7c 7f 7b 7e 78 70 78 73 7a 74 7c 7c 7c     ||||.{~xpxszt|||
     e1d:	3c 3c 18 00 00 00 00 00 00 00 00 00 00 00 00 00     <<..............
	...

00000e6d <ryu2>:
	...
     e7d:	80 c0 e0 e0 e0 e0 e0 c0 c0 00 00 00 00 00 00 00     ................
	...
     ef5:	00 e0 f0 08 04 02 01 80 5f 79 e7 8f 3b c7 7f 7f     ........_y..;...
     f05:	0f 1f 20 40 40 80 00 00 00 00 00 00 00 00 00 00     .. @@...........
	...
     f71:	00 00 f8 c8 ee 61 31 7c c0 fe cf e4 f4 fc f8 e1     .....a1|........
     f81:	73 49 e0 b8 2c 06 02 82 c6 fc 03 0c 00 00 00 00     sI..,...........
	...
     ff1:	00 00 01 03 06 ee 75 4f 3b 73 e7 fb e9 e7 af f4     ......uO;s......
    1001:	e0 40 80 e3 ac 38 1c 07 03 00 00 00 00 00 00 00     .@...8..........
	...
    1075:	00 ff 1c 06 03 01 02 06 0f ff f7 fe fe 78 f8 0d     .............x..
    1085:	06 05 06 08 08 10 60 80 00 00 00 00 00 00 00 00     ......`.........
	...
    10f1:	00 00 00 80 e0 3f 3c 00 00 00 00 00 80 ff 1f 03     .....?<.........
    1101:	06 0c 18 30 30 60 c0 40 00 00 00 00 03 1c 30 e0     ...00`.@......0.
	...
    1171:	00 00 00 9f f1 40 40 40 c0 60 ba 8f 87 81 80 80     .....@@@.`......
    1181:	80 80 80 00 00 00 01 07 0c 10 20 60 40 00 c0 c0     .......... `@...
    1191:	61 72 ce 80 00 00 00 00 00 00 00 00 00 00 00 00     ar..............
	...
    11ed:	18 3c 3c 7c 7c 7c 7c 7d 74 7c 7c 74 3b 3f 3f 3f     .<<||||}t||t;???
    11fd:	3f 3f 3f 3f 3f 3f 3f 3f 7f 7e 7e 7e 7e 7c 7c 7c     ????????.~~~~|||
    120d:	7c 7c 7f 79 7c 78 70 79 71 72 7c 7c 7c 7c 7c 7c     ||.y|xpyqr||||||
    121d:	3c 3c 18 00 00 00 00 00 00 00 00 00 00 00 00 00     <<..............
	...

0000126d <ryu1>:
	...
    1275:	00 00 80 40 40 20 c0 40 f0 7c de 3f 7f ff fe fe     ...@@ .@.|.?....
    1285:	fc 78 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .x..............
	...
    12f1:	00 00 00 80 fe 4d 7c c0 e0 e0 78 b2 18 ef 47 fc     .....M|...x...G.
    1301:	1a 9a ff 01 02 06 01 02 82 1c e0 20 00 00 00 00     ........... ....
	...
    1371:	00 00 1e 20 30 30 10 7b db 8f 86 1e 63 9f 7a bb     ... 00.{....c.z.
    1381:	de a7 c8 e0 f8 b0 78 fe 73 10 3f e0 00 00 00 00     ......x.s.?.....
	...
    13f5:	00 20 d0 c8 c4 83 06 06 0d 7d ff fc ed 26 07 83     . .......}...&..
    1405:	8b b6 e7 cf 2f 0c 06 03 00 00 00 00 00 00 00 00     ..../...........
	...
    1471:	00 00 00 80 e0 78 06 00 00 00 01 03 86 ee 7f 1f     .....x..........
    1481:	ff f7 7f 59 00 00 00 01 06 1c f0 00 00 00 00 00     ...Y............
	...
    14f5:	ff 00 00 00 00 00 28 fa ff 01 00 00 00 03 0e 1c     ......(.........
    1505:	38 f0 e0 c0 00 00 00 07 0e 3c 30 c0 80 00 00 00     8........<0.....
	...
    1575:	1f 20 e0 60 20 60 ba 9f 87 80 80 80 80 80 80 80     . .` `..........
    1585:	80 00 01 03 0e 3c 70 40 c0 e0 30 1c 67 80 00 00     .....<p@..0.g...
	...
    15ed:	18 3c 3c 7c 7c 7c 7c 7e 72 7f 7c 30 30 3c 3e 3f     .<<||||~r.|00<>?
    15fd:	3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 7f 7e 7e 7e 7e 7c     ??????????.~~~~|
    160d:	7c 74 3c 3c 18 19 1f 00 00 00 00 00 00 00 00 00     |t<<............
	...

0000166d <ryu0>:
    166d:	00 00 00 c0 20 18 cc e4 64 64 64 8c 18 08 0c 3e     .... ...ddd....>
    167d:	3f cf 3f 3f ff ff fe fc 78 00 00 00 00 00 00 00     ?.??....x.......
	...
    16ed:	00 00 00 3f c0 bf ff c7 80 08 09 0f 08 90 f0 f8     ...?............
    16fd:	f8 ff fe cc f3 01 e7 f5 18 00 00 00 00 00 00 00     ................
	...
    1771:	01 07 1c f9 f7 e5 c7 c3 c3 c1 e1 e0 df e0 75 db     ..............u.
    1781:	fd 3a e9 cf c0 30 00 c0 00 00 00 00 00 00 00 00     .:...0..........
	...
    17f1:	bc 4c 32 79 80 00 01 8d ff 8b ff f9 40 60 71 ff     .L2y........@`q.
    1801:	ed 0d 07 07 07 03 01 00 00 00 00 00 00 00 00 00     ................
	...
    186d:	00 c0 38 07 00 00 00 00 00 01 83 ff 7f ff 8f 07     ..8.............
    187d:	00 00 00 0f 07 ff f8 c0 00 00 00 00 00 00 00 00     ................
	...
    18ed:	00 3f c0 00 00 00 00 12 97 9f fb c1 80 00 07 1e     .?..............
    18fd:	30 e0 c0 00 00 07 17 1f 3c 78 e0 00 00 00 00 00     0.......<x......
	...
    196d:	00 00 03 0e 30 c0 00 00 80 00 05 47 ff 1e 00 00     ....0......G....
    197d:	00 01 03 0f 1c 38 e0 80 80 40 f1 ed 06 00 00 00     .....8...@......
	...
    19ed:	38 78 7c fc fc fe f6 ff e1 f0 f0 7e 7e 7f 7f 7f     8x|........~~...
    19fd:	7f 7f 7f 7f 7e 7e fe e1 e8 f0 f8 eb fe fc 7c 78     ....~~........|x
    1a0d:	78 30 00 00 00 00 00 00 00 00 00 00 00 00 00 00     x0..............
	...

00001a6e <__ctors_end>:
    1a6e:	11 24       	eor	r1, r1
    1a70:	1f be       	out	0x3f, r1	; 63
    1a72:	cf ef       	ldi	r28, 0xFF	; 255
    1a74:	d8 e0       	ldi	r29, 0x08	; 8
    1a76:	de bf       	out	0x3e, r29	; 62
    1a78:	cd bf       	out	0x3d, r28	; 61

00001a7a <__do_copy_data>:
    1a7a:	11 e0       	ldi	r17, 0x01	; 1
    1a7c:	a0 e0       	ldi	r26, 0x00	; 0
    1a7e:	b1 e0       	ldi	r27, 0x01	; 1
    1a80:	ec ea       	ldi	r30, 0xAC	; 172
    1a82:	f0 e2       	ldi	r31, 0x20	; 32
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <__do_copy_data+0x10>
    1a86:	05 90       	lpm	r0, Z+
    1a88:	0d 92       	st	X+, r0
    1a8a:	a8 32       	cpi	r26, 0x28	; 40
    1a8c:	b1 07       	cpc	r27, r17
    1a8e:	d9 f7       	brne	.-10     	; 0x1a86 <__do_copy_data+0xc>
    1a90:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <main>
    1a94:	0c 94 54 10 	jmp	0x20a8	; 0x20a8 <_exit>

00001a98 <__bad_interrupt>:
    1a98:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001a9c <Inicializacao_Display>:
#include "tabela_ASCII.h"

/* Esta função inicializa o display gráfico 128x64 */
void Inicializacao_Display(void)
{
	DIR_DADOS = 0xFF;         //configura o barramento de dados como saída
    1a9c:	8f ef       	ldi	r24, 0xFF	; 255
    1a9e:	8a b9       	out	0x0a, r24	; 10
	DIR_CONT = 0xFF;          //configura o barramento de controle como saída
    1aa0:	87 b9       	out	0x07, r24	; 7
	set_bit(PORT_CONT, _CS1); //habilita o chip 1
    1aa2:	88 b1       	in	r24, 0x08	; 8
    1aa4:	81 60       	ori	r24, 0x01	; 1
    1aa6:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _CS2); //habilita o chip 2
    1aa8:	88 b1       	in	r24, 0x08	; 8
    1aaa:	82 60       	ori	r24, 0x02	; 2
    1aac:	88 b9       	out	0x08, r24	; 8
	pulso_reset();            //reseta o controlador do display gráfico
    1aae:	88 b1       	in	r24, 0x08	; 8
    1ab0:	8f 7d       	andi	r24, 0xDF	; 223
    1ab2:	88 b9       	out	0x08, r24	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1ab4:	8a e0       	ldi	r24, 0x0A	; 10
    1ab6:	8a 95       	dec	r24
    1ab8:	f1 f7       	brne	.-4      	; 0x1ab6 <Inicializacao_Display+0x1a>
    1aba:	00 c0       	rjmp	.+0      	; 0x1abc <Inicializacao_Display+0x20>
    1abc:	88 b1       	in	r24, 0x08	; 8
    1abe:	80 62       	ori	r24, 0x20	; 32
    1ac0:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RS);  //instrução
    1ac2:	88 b1       	in	r24, 0x08	; 8
    1ac4:	8b 7f       	andi	r24, 0xFB	; 251
    1ac6:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RW);  //escrita
    1ac8:	88 b1       	in	r24, 0x08	; 8
    1aca:	87 7f       	andi	r24, 0xF7	; 247
    1acc:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = 0x3F;        //liga a tela do display
    1ace:	8f e3       	ldi	r24, 0x3F	; 63
    1ad0:	8b b9       	out	0x0b, r24	; 11
    1ad2:	85 e3       	ldi	r24, 0x35	; 53
    1ad4:	8a 95       	dec	r24
    1ad6:	f1 f7       	brne	.-4      	; 0x1ad4 <Inicializacao_Display+0x38>
    1ad8:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1ada:	88 b1       	in	r24, 0x08	; 8
    1adc:	80 61       	ori	r24, 0x10	; 16
    1ade:	88 b9       	out	0x08, r24	; 8
    1ae0:	85 e3       	ldi	r24, 0x35	; 53
    1ae2:	8a 95       	dec	r24
    1ae4:	f1 f7       	brne	.-4      	; 0x1ae2 <Inicializacao_Display+0x46>
    1ae6:	00 00       	nop
    1ae8:	88 b1       	in	r24, 0x08	; 8
    1aea:	8f 7e       	andi	r24, 0xEF	; 239
    1aec:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = 0x40;        //ajusta o endereço Y(contador de coluna)
    1aee:	80 e4       	ldi	r24, 0x40	; 64
    1af0:	8b b9       	out	0x0b, r24	; 11
    1af2:	85 e3       	ldi	r24, 0x35	; 53
    1af4:	8a 95       	dec	r24
    1af6:	f1 f7       	brne	.-4      	; 0x1af4 <Inicializacao_Display+0x58>
    1af8:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1afa:	88 b1       	in	r24, 0x08	; 8
    1afc:	80 61       	ori	r24, 0x10	; 16
    1afe:	88 b9       	out	0x08, r24	; 8
    1b00:	85 e3       	ldi	r24, 0x35	; 53
    1b02:	8a 95       	dec	r24
    1b04:	f1 f7       	brne	.-4      	; 0x1b02 <Inicializacao_Display+0x66>
    1b06:	00 00       	nop
    1b08:	88 b1       	in	r24, 0x08	; 8
    1b0a:	8f 7e       	andi	r24, 0xEF	; 239
    1b0c:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = 0xB8;        //ajusta o endereço X(página)
    1b0e:	88 eb       	ldi	r24, 0xB8	; 184
    1b10:	8b b9       	out	0x0b, r24	; 11
    1b12:	85 e3       	ldi	r24, 0x35	; 53
    1b14:	8a 95       	dec	r24
    1b16:	f1 f7       	brne	.-4      	; 0x1b14 <Inicializacao_Display+0x78>
    1b18:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1b1a:	88 b1       	in	r24, 0x08	; 8
    1b1c:	80 61       	ori	r24, 0x10	; 16
    1b1e:	88 b9       	out	0x08, r24	; 8
    1b20:	85 e3       	ldi	r24, 0x35	; 53
    1b22:	8a 95       	dec	r24
    1b24:	f1 f7       	brne	.-4      	; 0x1b22 <Inicializacao_Display+0x86>
    1b26:	00 00       	nop
    1b28:	88 b1       	in	r24, 0x08	; 8
    1b2a:	8f 7e       	andi	r24, 0xEF	; 239
    1b2c:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = 0xC0;        //indica os dados mostrados no topo da tela
    1b2e:	80 ec       	ldi	r24, 0xC0	; 192
    1b30:	8b b9       	out	0x0b, r24	; 11
    1b32:	85 e3       	ldi	r24, 0x35	; 53
    1b34:	8a 95       	dec	r24
    1b36:	f1 f7       	brne	.-4      	; 0x1b34 <Inicializacao_Display+0x98>
    1b38:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1b3a:	88 b1       	in	r24, 0x08	; 8
    1b3c:	80 61       	ori	r24, 0x10	; 16
    1b3e:	88 b9       	out	0x08, r24	; 8
    1b40:	85 e3       	ldi	r24, 0x35	; 53
    1b42:	8a 95       	dec	r24
    1b44:	f1 f7       	brne	.-4      	; 0x1b42 <Inicializacao_Display+0xa6>
    1b46:	00 00       	nop
    1b48:	88 b1       	in	r24, 0x08	; 8
    1b4a:	8f 7e       	andi	r24, 0xEF	; 239
    1b4c:	88 b9       	out	0x08, r24	; 8
    1b4e:	08 95       	ret

00001b50 <Status_BF>:
}

/* Esta função verifica o status do busy flag: 1 - ocupado; 0 - livre */
char Status_BF(void)
{
	DIR_DADOS = 0x00;                  //configura o barramento de dados como entrada
    1b50:	1a b8       	out	0x0a, r1	; 10
	//enviando a instrução
	set_bit(PORT_CONT, _CS1);          //habilita o chip 1
    1b52:	88 b1       	in	r24, 0x08	; 8
    1b54:	81 60       	ori	r24, 0x01	; 1
    1b56:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _CS2);          //habilita o chip 2
    1b58:	88 b1       	in	r24, 0x08	; 8
    1b5a:	82 60       	ori	r24, 0x02	; 2
    1b5c:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RS);           //instrução
    1b5e:	88 b1       	in	r24, 0x08	; 8
    1b60:	8b 7f       	andi	r24, 0xFB	; 251
    1b62:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _RW);           //leitura
    1b64:	88 b1       	in	r24, 0x08	; 8
    1b66:	88 60       	ori	r24, 0x08	; 8
    1b68:	88 b9       	out	0x08, r24	; 8
    1b6a:	85 e3       	ldi	r24, 0x35	; 53
    1b6c:	8a 95       	dec	r24
    1b6e:	f1 f7       	brne	.-4      	; 0x1b6c <Status_BF+0x1c>
    1b70:	00 00       	nop
	pulso_enable();                    //envia um pulso no pino enable
    1b72:	88 b1       	in	r24, 0x08	; 8
    1b74:	80 61       	ori	r24, 0x10	; 16
    1b76:	88 b9       	out	0x08, r24	; 8
    1b78:	85 e3       	ldi	r24, 0x35	; 53
    1b7a:	8a 95       	dec	r24
    1b7c:	f1 f7       	brne	.-4      	; 0x1b7a <Status_BF+0x2a>
    1b7e:	00 00       	nop
    1b80:	88 b1       	in	r24, 0x08	; 8
    1b82:	8f 7e       	andi	r24, 0xEF	; 239
    1b84:	88 b9       	out	0x08, r24	; 8
	//le o bit 7 do barramento de dados
	if(tst_bit(LE_DADOS, 7)) return 1; //controlador ocupado
    1b86:	4f 9b       	sbis	0x09, 7	; 9
    1b88:	02 c0       	rjmp	.+4      	; 0x1b8e <Status_BF+0x3e>
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	08 95       	ret
	else                     return 0; //controlador livre
    1b8e:	80 e0       	ldi	r24, 0x00	; 0
	DIR_DADOS = 0xFF;                  //configura o barramento de dados como saída
}
    1b90:	08 95       	ret

00001b92 <Escreve_Instrucao>:
	pulso_enable();           //envia um pulso no pino enable
}

/* Esta função encreve uma instrução no display */
void Escreve_Instrucao(char instrucao)
{
    1b92:	cf 93       	push	r28
    1b94:	c8 2f       	mov	r28, r24
	while(Status_BF());       //aguarda o display estar livre
    1b96:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1b9a:	81 11       	cpse	r24, r1
    1b9c:	fc cf       	rjmp	.-8      	; 0x1b96 <Escreve_Instrucao+0x4>
	set_bit(PORT_CONT, _CS1); //habilita o chip 1
    1b9e:	88 b1       	in	r24, 0x08	; 8
    1ba0:	81 60       	ori	r24, 0x01	; 1
    1ba2:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _CS2); //habilita o chip 2
    1ba4:	88 b1       	in	r24, 0x08	; 8
    1ba6:	82 60       	ori	r24, 0x02	; 2
    1ba8:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RS);  //instrução
    1baa:	88 b1       	in	r24, 0x08	; 8
    1bac:	8b 7f       	andi	r24, 0xFB	; 251
    1bae:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RW);  //escrita
    1bb0:	88 b1       	in	r24, 0x08	; 8
    1bb2:	87 7f       	andi	r24, 0xF7	; 247
    1bb4:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = instrucao;   //escreve instrução no barramento de dados
    1bb6:	cb b9       	out	0x0b, r28	; 11
    1bb8:	85 e3       	ldi	r24, 0x35	; 53
    1bba:	8a 95       	dec	r24
    1bbc:	f1 f7       	brne	.-4      	; 0x1bba <Escreve_Instrucao+0x28>
    1bbe:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1bc0:	88 b1       	in	r24, 0x08	; 8
    1bc2:	80 61       	ori	r24, 0x10	; 16
    1bc4:	88 b9       	out	0x08, r24	; 8
    1bc6:	85 e3       	ldi	r24, 0x35	; 53
    1bc8:	8a 95       	dec	r24
    1bca:	f1 f7       	brne	.-4      	; 0x1bc8 <Escreve_Instrucao+0x36>
    1bcc:	00 00       	nop
    1bce:	88 b1       	in	r24, 0x08	; 8
    1bd0:	8f 7e       	andi	r24, 0xEF	; 239
    1bd2:	88 b9       	out	0x08, r24	; 8
}
    1bd4:	cf 91       	pop	r28
    1bd6:	08 95       	ret

00001bd8 <Posiciona_Pagina>:
	return leitura;           //retorna o dado lido
}

/* Esta função ajusta o endereço X(página)*/
void Posiciona_Pagina(char pagina)
{
    1bd8:	cf 93       	push	r28
    1bda:	c8 2f       	mov	r28, r24
	while(Status_BF());               //aguarda o display estar livre
    1bdc:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1be0:	81 11       	cpse	r24, r1
    1be2:	fc cf       	rjmp	.-8      	; 0x1bdc <Posiciona_Pagina+0x4>
	Escreve_Instrucao(0xB8 + pagina); //ajusta o endereço X para 'pagina'
    1be4:	88 eb       	ldi	r24, 0xB8	; 184
    1be6:	8c 0f       	add	r24, r28
    1be8:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <Escreve_Instrucao>
}
    1bec:	cf 91       	pop	r28
    1bee:	08 95       	ret

00001bf0 <Posiciona_Coluna>:

/* Esta função ajusta o endereço Y(coluna) */
void Posiciona_Coluna(char coluna)
{
    1bf0:	cf 93       	push	r28
    1bf2:	c8 2f       	mov	r28, r24
	while(Status_BF());               //aguarda o display estar livre
    1bf4:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1bf8:	81 11       	cpse	r24, r1
    1bfa:	fc cf       	rjmp	.-8      	; 0x1bf4 <Posiciona_Coluna+0x4>
	if(coluna > 63) coluna -= 64;     //ajusta o valor de 'coluna', para 'coluna' maior do que 63
    1bfc:	c0 34       	cpi	r28, 0x40	; 64
    1bfe:	08 f0       	brcs	.+2      	; 0x1c02 <Posiciona_Coluna+0x12>
    1c00:	c0 54       	subi	r28, 0x40	; 64
	Escreve_Instrucao(0x40 + coluna); //ajusta o endereço Y para 'coluna'
    1c02:	80 e4       	ldi	r24, 0x40	; 64
    1c04:	8c 0f       	add	r24, r28
    1c06:	0e 94 c9 0d 	call	0x1b92	; 0x1b92 <Escreve_Instrucao>
}
    1c0a:	cf 91       	pop	r28
    1c0c:	08 95       	ret

00001c0e <Escreve_Dado>:
	DIR_DADOS = 0xFF;                  //configura o barramento de dados como saída
}

/* Esta função escreve um byte de dados no display */
void Escreve_Dado(char dado, unsigned char pagina, unsigned char coluna)
{
    1c0e:	1f 93       	push	r17
    1c10:	cf 93       	push	r28
    1c12:	df 93       	push	r29
    1c14:	d8 2f       	mov	r29, r24
    1c16:	16 2f       	mov	r17, r22
    1c18:	c4 2f       	mov	r28, r20
	while(Status_BF());       //aguarda o display estar livre
    1c1a:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1c1e:	81 11       	cpse	r24, r1
    1c20:	fc cf       	rjmp	.-8      	; 0x1c1a <Escreve_Dado+0xc>
	Posiciona_Pagina(pagina); //ajusta a página
    1c22:	81 2f       	mov	r24, r17
    1c24:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <Posiciona_Pagina>
	Posiciona_Coluna(coluna); //ajusta a coluna
    1c28:	8c 2f       	mov	r24, r28
    1c2a:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <Posiciona_Coluna>
	clr_bit(PORT_CONT, _CS1); //desabilita o chip 1
    1c2e:	88 b1       	in	r24, 0x08	; 8
    1c30:	8e 7f       	andi	r24, 0xFE	; 254
    1c32:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _CS2); //desabilita o chip 2
    1c34:	88 b1       	in	r24, 0x08	; 8
    1c36:	8d 7f       	andi	r24, 0xFD	; 253
    1c38:	88 b9       	out	0x08, r24	; 8
	if(coluna < 64) set_bit(PORT_CONT, _CS1); //habilita o chip 1
    1c3a:	c0 34       	cpi	r28, 0x40	; 64
    1c3c:	20 f4       	brcc	.+8      	; 0x1c46 <Escreve_Dado+0x38>
    1c3e:	88 b1       	in	r24, 0x08	; 8
    1c40:	81 60       	ori	r24, 0x01	; 1
    1c42:	88 b9       	out	0x08, r24	; 8
    1c44:	03 c0       	rjmp	.+6      	; 0x1c4c <Escreve_Dado+0x3e>
	else            set_bit(PORT_CONT, _CS2); //habilita o chip 2
    1c46:	88 b1       	in	r24, 0x08	; 8
    1c48:	82 60       	ori	r24, 0x02	; 2
    1c4a:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _RS);  //dado
    1c4c:	88 b1       	in	r24, 0x08	; 8
    1c4e:	84 60       	ori	r24, 0x04	; 4
    1c50:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _RW);  //escrita
    1c52:	88 b1       	in	r24, 0x08	; 8
    1c54:	87 7f       	andi	r24, 0xF7	; 247
    1c56:	88 b9       	out	0x08, r24	; 8
	PORT_DADOS = dado;        //carrega o dado no barramento de dados
    1c58:	db b9       	out	0x0b, r29	; 11
    1c5a:	85 e3       	ldi	r24, 0x35	; 53
    1c5c:	8a 95       	dec	r24
    1c5e:	f1 f7       	brne	.-4      	; 0x1c5c <Escreve_Dado+0x4e>
    1c60:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1c62:	88 b1       	in	r24, 0x08	; 8
    1c64:	80 61       	ori	r24, 0x10	; 16
    1c66:	88 b9       	out	0x08, r24	; 8
    1c68:	85 e3       	ldi	r24, 0x35	; 53
    1c6a:	8a 95       	dec	r24
    1c6c:	f1 f7       	brne	.-4      	; 0x1c6a <Escreve_Dado+0x5c>
    1c6e:	00 00       	nop
    1c70:	88 b1       	in	r24, 0x08	; 8
    1c72:	8f 7e       	andi	r24, 0xEF	; 239
    1c74:	88 b9       	out	0x08, r24	; 8
}
    1c76:	df 91       	pop	r29
    1c78:	cf 91       	pop	r28
    1c7a:	1f 91       	pop	r17
    1c7c:	08 95       	ret

00001c7e <Leitura_Dado>:

/* Esta função lê um byte de dados do display */
char Leitura_Dado(unsigned char pagina, unsigned char coluna)
{
    1c7e:	cf 93       	push	r28
    1c80:	df 93       	push	r29
    1c82:	d8 2f       	mov	r29, r24
    1c84:	c6 2f       	mov	r28, r22
	char leitura;             //variável auxiliar
	while(Status_BF());       //aguarda o display estar livre
    1c86:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1c8a:	81 11       	cpse	r24, r1
    1c8c:	fc cf       	rjmp	.-8      	; 0x1c86 <Leitura_Dado+0x8>
	DIR_DADOS = 0x00;         //configura o barramento de dados como entrada
    1c8e:	1a b8       	out	0x0a, r1	; 10
	Posiciona_Pagina(pagina); //ajusta a página
    1c90:	8d 2f       	mov	r24, r29
    1c92:	0e 94 ec 0d 	call	0x1bd8	; 0x1bd8 <Posiciona_Pagina>
	Posiciona_Coluna(coluna); //ajusta a coluna
    1c96:	8c 2f       	mov	r24, r28
    1c98:	0e 94 f8 0d 	call	0x1bf0	; 0x1bf0 <Posiciona_Coluna>
	clr_bit(PORT_CONT, _CS1); //desabilita o chip 1
    1c9c:	88 b1       	in	r24, 0x08	; 8
    1c9e:	8e 7f       	andi	r24, 0xFE	; 254
    1ca0:	88 b9       	out	0x08, r24	; 8
	clr_bit(PORT_CONT, _CS2); //desabilita o chip 2
    1ca2:	88 b1       	in	r24, 0x08	; 8
    1ca4:	8d 7f       	andi	r24, 0xFD	; 253
    1ca6:	88 b9       	out	0x08, r24	; 8
	//envia instrução
	if(coluna < 64) set_bit(PORT_CONT, _CS1);
    1ca8:	c0 34       	cpi	r28, 0x40	; 64
    1caa:	20 f4       	brcc	.+8      	; 0x1cb4 <Leitura_Dado+0x36>
    1cac:	88 b1       	in	r24, 0x08	; 8
    1cae:	81 60       	ori	r24, 0x01	; 1
    1cb0:	88 b9       	out	0x08, r24	; 8
    1cb2:	03 c0       	rjmp	.+6      	; 0x1cba <Leitura_Dado+0x3c>
	else            set_bit(PORT_CONT, _CS2);
    1cb4:	88 b1       	in	r24, 0x08	; 8
    1cb6:	82 60       	ori	r24, 0x02	; 2
    1cb8:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _RS);  //dado
    1cba:	88 b1       	in	r24, 0x08	; 8
    1cbc:	84 60       	ori	r24, 0x04	; 4
    1cbe:	88 b9       	out	0x08, r24	; 8
	set_bit(PORT_CONT, _RW);  //leitura
    1cc0:	88 b1       	in	r24, 0x08	; 8
    1cc2:	88 60       	ori	r24, 0x08	; 8
    1cc4:	88 b9       	out	0x08, r24	; 8
    1cc6:	85 e3       	ldi	r24, 0x35	; 53
    1cc8:	8a 95       	dec	r24
    1cca:	f1 f7       	brne	.-4      	; 0x1cc8 <Leitura_Dado+0x4a>
    1ccc:	00 00       	nop
	pulso_enable();           //envia um pulso no pino enable
    1cce:	88 b1       	in	r24, 0x08	; 8
    1cd0:	80 61       	ori	r24, 0x10	; 16
    1cd2:	88 b9       	out	0x08, r24	; 8
    1cd4:	85 e3       	ldi	r24, 0x35	; 53
    1cd6:	8a 95       	dec	r24
    1cd8:	f1 f7       	brne	.-4      	; 0x1cd6 <Leitura_Dado+0x58>
    1cda:	00 00       	nop
    1cdc:	88 b1       	in	r24, 0x08	; 8
    1cde:	8f 7e       	andi	r24, 0xEF	; 239
    1ce0:	88 b9       	out	0x08, r24	; 8
	leitura = LE_DADOS;       //leitura 'dummy'
    1ce2:	89 b1       	in	r24, 0x09	; 9
    1ce4:	85 e3       	ldi	r24, 0x35	; 53
    1ce6:	8a 95       	dec	r24
    1ce8:	f1 f7       	brne	.-4      	; 0x1ce6 <Leitura_Dado+0x68>
    1cea:	00 00       	nop
	//lê o dado
	pulso_enable();           //envia um pulso no pino enable
    1cec:	88 b1       	in	r24, 0x08	; 8
    1cee:	80 61       	ori	r24, 0x10	; 16
    1cf0:	88 b9       	out	0x08, r24	; 8
    1cf2:	85 e3       	ldi	r24, 0x35	; 53
    1cf4:	8a 95       	dec	r24
    1cf6:	f1 f7       	brne	.-4      	; 0x1cf4 <Leitura_Dado+0x76>
    1cf8:	00 00       	nop
    1cfa:	88 b1       	in	r24, 0x08	; 8
    1cfc:	8f 7e       	andi	r24, 0xEF	; 239
    1cfe:	88 b9       	out	0x08, r24	; 8
	leitura = LE_DADOS;       //leitura efetiva
    1d00:	89 b1       	in	r24, 0x09	; 9
	DIR_DADOS = 0xFF;         //configura o barramento de dados como saída
    1d02:	9f ef       	ldi	r25, 0xFF	; 255
    1d04:	9a b9       	out	0x0a, r25	; 10
	return leitura;           //retorna o dado lido
}
    1d06:	df 91       	pop	r29
    1d08:	cf 91       	pop	r28
    1d0a:	08 95       	ret

00001d0c <Escreve_S_memdados>:
	Escreve_Instrucao(0x40 + coluna); //ajusta o endereço Y para 'coluna'
}

/* Esta função imprime uma string armazenada na memória de dados */
void Escreve_S_memdados(char *string, unsigned char pagina, unsigned char coluna)
{
    1d0c:	ef 92       	push	r14
    1d0e:	ff 92       	push	r15
    1d10:	0f 93       	push	r16
    1d12:	1f 93       	push	r17
    1d14:	cf 93       	push	r28
    1d16:	df 93       	push	r29
    1d18:	ec 01       	movw	r28, r24
    1d1a:	e6 2e       	mov	r14, r22
    1d1c:	04 2f       	mov	r16, r20
	while(*string) //enquanto não encontrar o caractere nulo("\0")...
    1d1e:	29 c0       	rjmp	.+82     	; 0x1d72 <Escreve_S_memdados+0x66>
	{
		while(Status_BF());                   //aguarda o display estar livre
    1d20:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1d24:	81 11       	cpse	r24, r1
    1d26:	fc cf       	rjmp	.-8      	; 0x1d20 <Escreve_S_memdados+0x14>
    1d28:	10 e0       	ldi	r17, 0x00	; 0
    1d2a:	18 c0       	rjmp	.+48     	; 0x1d5c <Escreve_S_memdados+0x50>
		for(unsigned char i = 0; i < 5; i++)  //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[*string - 0x20][i]), pagina, coluna++);
    1d2c:	ff 24       	eor	r15, r15
    1d2e:	f3 94       	inc	r15
    1d30:	f0 0e       	add	r15, r16
    1d32:	88 81       	ld	r24, Y
    1d34:	90 e0       	ldi	r25, 0x00	; 0
    1d36:	80 97       	sbiw	r24, 0x20	; 32
    1d38:	fc 01       	movw	r30, r24
    1d3a:	ee 0f       	add	r30, r30
    1d3c:	ff 1f       	adc	r31, r31
    1d3e:	ee 0f       	add	r30, r30
    1d40:	ff 1f       	adc	r31, r31
    1d42:	e8 0f       	add	r30, r24
    1d44:	f9 1f       	adc	r31, r25
    1d46:	e1 0f       	add	r30, r17
    1d48:	f1 1d       	adc	r31, r1
    1d4a:	e8 59       	subi	r30, 0x98	; 152
    1d4c:	ff 4f       	sbci	r31, 0xFF	; 255
    1d4e:	84 91       	lpm	r24, Z
    1d50:	40 2f       	mov	r20, r16
    1d52:	6e 2d       	mov	r22, r14
    1d54:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
void Escreve_S_memdados(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string) //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //varre as 5 colunas
    1d58:	1f 5f       	subi	r17, 0xFF	; 255
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[*string - 0x20][i]), pagina, coluna++);
    1d5a:	0f 2d       	mov	r16, r15
void Escreve_S_memdados(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string) //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //varre as 5 colunas
    1d5c:	15 30       	cpi	r17, 0x05	; 5
    1d5e:	30 f3       	brcs	.-52     	; 0x1d2c <Escreve_S_memdados+0x20>
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[*string - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++); //espaço em branco
    1d60:	11 e0       	ldi	r17, 0x01	; 1
    1d62:	10 0f       	add	r17, r16
    1d64:	40 2f       	mov	r20, r16
    1d66:	6e 2d       	mov	r22, r14
    1d68:	80 e0       	ldi	r24, 0x00	; 0
    1d6a:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		string++;                             //próximo elemento da string
    1d6e:	21 96       	adiw	r28, 0x01	; 1
	while(*string) //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[*string - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++); //espaço em branco
    1d70:	01 2f       	mov	r16, r17
}

/* Esta função imprime uma string armazenada na memória de dados */
void Escreve_S_memdados(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string) //enquanto não encontrar o caractere nulo("\0")...
    1d72:	88 81       	ld	r24, Y
    1d74:	81 11       	cpse	r24, r1
    1d76:	d4 cf       	rjmp	.-88     	; 0x1d20 <Escreve_S_memdados+0x14>
		for(unsigned char i = 0; i < 5; i++)  //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[*string - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++); //espaço em branco
		string++;                             //próximo elemento da string
	}
}
    1d78:	df 91       	pop	r29
    1d7a:	cf 91       	pop	r28
    1d7c:	1f 91       	pop	r17
    1d7e:	0f 91       	pop	r16
    1d80:	ff 90       	pop	r15
    1d82:	ef 90       	pop	r14
    1d84:	08 95       	ret

00001d86 <Escreve_S_memprogm>:

/* Esta função imprime uma string armazenada na memória de programa */
void Escreve_S_memprogm(const char *string, unsigned char pagina, unsigned char coluna)
{
    1d86:	af 92       	push	r10
    1d88:	bf 92       	push	r11
    1d8a:	cf 92       	push	r12
    1d8c:	df 92       	push	r13
    1d8e:	ef 92       	push	r14
    1d90:	0f 93       	push	r16
    1d92:	1f 93       	push	r17
    1d94:	cf 93       	push	r28
    1d96:	8c 01       	movw	r16, r24
    1d98:	c6 2e       	mov	r12, r22
    1d9a:	e4 2e       	mov	r14, r20
	while(pgm_read_byte(string))               //enquanto não encontrar o caractere nulo("\0")...
    1d9c:	2b c0       	rjmp	.+86     	; 0x1df4 <Escreve_S_memprogm+0x6e>
	{
		while(Status_BF());                    //aguarda o display estar livre
    1d9e:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1da2:	81 11       	cpse	r24, r1
    1da4:	fc cf       	rjmp	.-8      	; 0x1d9e <Escreve_S_memprogm+0x18>
    1da6:	c0 e0       	ldi	r28, 0x00	; 0
    1da8:	19 c0       	rjmp	.+50     	; 0x1ddc <Escreve_S_memprogm+0x56>
		for(unsigned char i = 0; i < 5; i++)   //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i]), pagina, coluna++);
    1daa:	dd 24       	eor	r13, r13
    1dac:	d3 94       	inc	r13
    1dae:	de 0c       	add	r13, r14
    1db0:	f5 01       	movw	r30, r10
    1db2:	84 91       	lpm	r24, Z
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	80 97       	sbiw	r24, 0x20	; 32
    1db8:	fc 01       	movw	r30, r24
    1dba:	ee 0f       	add	r30, r30
    1dbc:	ff 1f       	adc	r31, r31
    1dbe:	ee 0f       	add	r30, r30
    1dc0:	ff 1f       	adc	r31, r31
    1dc2:	e8 0f       	add	r30, r24
    1dc4:	f9 1f       	adc	r31, r25
    1dc6:	ec 0f       	add	r30, r28
    1dc8:	f1 1d       	adc	r31, r1
    1dca:	e8 59       	subi	r30, 0x98	; 152
    1dcc:	ff 4f       	sbci	r31, 0xFF	; 255
    1dce:	84 91       	lpm	r24, Z
    1dd0:	4e 2d       	mov	r20, r14
    1dd2:	6c 2d       	mov	r22, r12
    1dd4:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
void Escreve_S_memprogm(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))               //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                    //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)   //varre as 5 colunas
    1dd8:	cf 5f       	subi	r28, 0xFF	; 255
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i]), pagina, coluna++);
    1dda:	ed 2c       	mov	r14, r13
void Escreve_S_memprogm(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))               //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                    //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)   //varre as 5 colunas
    1ddc:	c5 30       	cpi	r28, 0x05	; 5
    1dde:	28 f3       	brcs	.-54     	; 0x1daa <Escreve_S_memprogm+0x24>
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++);  //espaço em branco
    1de0:	c1 e0       	ldi	r28, 0x01	; 1
    1de2:	ce 0d       	add	r28, r14
    1de4:	4e 2d       	mov	r20, r14
    1de6:	6c 2d       	mov	r22, r12
    1de8:	80 e0       	ldi	r24, 0x00	; 0
    1dea:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		string++;                              //próximo elemento da string
    1dee:	0f 5f       	subi	r16, 0xFF	; 255
    1df0:	1f 4f       	sbci	r17, 0xFF	; 255
	while(pgm_read_byte(string))               //enquanto não encontrar o caractere nulo("\0")...
	{
		while(Status_BF());                    //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)   //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++);  //espaço em branco
    1df2:	ec 2e       	mov	r14, r28
}

/* Esta função imprime uma string armazenada na memória de programa */
void Escreve_S_memprogm(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))               //enquanto não encontrar o caractere nulo("\0")...
    1df4:	58 01       	movw	r10, r16
    1df6:	f8 01       	movw	r30, r16
    1df8:	84 91       	lpm	r24, Z
    1dfa:	81 11       	cpse	r24, r1
    1dfc:	d0 cf       	rjmp	.-96     	; 0x1d9e <Escreve_S_memprogm+0x18>
		for(unsigned char i = 0; i < 5; i++)   //varre as 5 colunas
		    Escreve_Dado(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i]), pagina, coluna++);
		Escreve_Dado(0x00, pagina, coluna++);  //espaço em branco
		string++;                              //próximo elemento da string
	}
}
    1dfe:	cf 91       	pop	r28
    1e00:	1f 91       	pop	r17
    1e02:	0f 91       	pop	r16
    1e04:	ef 90       	pop	r14
    1e06:	df 90       	pop	r13
    1e08:	cf 90       	pop	r12
    1e0a:	bf 90       	pop	r11
    1e0c:	af 90       	pop	r10
    1e0e:	08 95       	ret

00001e10 <Imprime_Imagem>:

/* Esta função imprime uma imagem armazenada na memória de programa */
void Imprime_Imagem(const char *imagem)
{
    1e10:	0f 93       	push	r16
    1e12:	1f 93       	push	r17
    1e14:	cf 93       	push	r28
    1e16:	df 93       	push	r29
    1e18:	fc 01       	movw	r30, r24
	for(unsigned char pagina = 0; pagina < 8; pagina++)             //varre as 8 páginas
    1e1a:	d0 e0       	ldi	r29, 0x00	; 0
    1e1c:	0f c0       	rjmp	.+30     	; 0x1e3c <Imprime_Imagem+0x2c>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++)       //varre as 128 colunas
		    Escreve_Dado(pgm_read_byte(imagem++), pagina, coluna);  //escreve o dado
    1e1e:	8f 01       	movw	r16, r30
    1e20:	0f 5f       	subi	r16, 0xFF	; 255
    1e22:	1f 4f       	sbci	r17, 0xFF	; 255
    1e24:	84 91       	lpm	r24, Z
    1e26:	4c 2f       	mov	r20, r28
    1e28:	6d 2f       	mov	r22, r29
    1e2a:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
/* Esta função imprime uma imagem armazenada na memória de programa */
void Imprime_Imagem(const char *imagem)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)             //varre as 8 páginas
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++)       //varre as 128 colunas
    1e2e:	cf 5f       	subi	r28, 0xFF	; 255
		    Escreve_Dado(pgm_read_byte(imagem++), pagina, coluna);  //escreve o dado
    1e30:	f8 01       	movw	r30, r16
    1e32:	01 c0       	rjmp	.+2      	; 0x1e36 <Imprime_Imagem+0x26>
    1e34:	c0 e0       	ldi	r28, 0x00	; 0
/* Esta função imprime uma imagem armazenada na memória de programa */
void Imprime_Imagem(const char *imagem)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)             //varre as 8 páginas
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++)       //varre as 128 colunas
    1e36:	cc 23       	and	r28, r28
    1e38:	94 f7       	brge	.-28     	; 0x1e1e <Imprime_Imagem+0xe>
}

/* Esta função imprime uma imagem armazenada na memória de programa */
void Imprime_Imagem(const char *imagem)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)             //varre as 8 páginas
    1e3a:	df 5f       	subi	r29, 0xFF	; 255
    1e3c:	d8 30       	cpi	r29, 0x08	; 8
    1e3e:	d0 f3       	brcs	.-12     	; 0x1e34 <Imprime_Imagem+0x24>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++)       //varre as 128 colunas
		    Escreve_Dado(pgm_read_byte(imagem++), pagina, coluna);  //escreve o dado
	}
}
    1e40:	df 91       	pop	r29
    1e42:	cf 91       	pop	r28
    1e44:	1f 91       	pop	r17
    1e46:	0f 91       	pop	r16
    1e48:	08 95       	ret

00001e4a <Testa_Display>:

/* Esta função liga todos os pixels do display */
void Testa_Display(void)
{
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 128 colunas
    1e4e:	d0 e0       	ldi	r29, 0x00	; 0
    1e50:	0b c0       	rjmp	.+22     	; 0x1e68 <Testa_Display+0x1e>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 8 páginas
		    Escreve_Dado(0xFF, pagina, coluna);               //escreve o dado
    1e52:	4c 2f       	mov	r20, r28
    1e54:	6d 2f       	mov	r22, r29
    1e56:	8f ef       	ldi	r24, 0xFF	; 255
    1e58:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
/* Esta função liga todos os pixels do display */
void Testa_Display(void)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 128 colunas
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 8 páginas
    1e5c:	cf 5f       	subi	r28, 0xFF	; 255
    1e5e:	01 c0       	rjmp	.+2      	; 0x1e62 <Testa_Display+0x18>
    1e60:	c0 e0       	ldi	r28, 0x00	; 0
    1e62:	cc 23       	and	r28, r28
    1e64:	b4 f7       	brge	.-20     	; 0x1e52 <Testa_Display+0x8>
}

/* Esta função liga todos os pixels do display */
void Testa_Display(void)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 128 colunas
    1e66:	df 5f       	subi	r29, 0xFF	; 255
    1e68:	d8 30       	cpi	r29, 0x08	; 8
    1e6a:	d0 f3       	brcs	.-12     	; 0x1e60 <Testa_Display+0x16>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 8 páginas
		    Escreve_Dado(0xFF, pagina, coluna);               //escreve o dado
	}
}
    1e6c:	df 91       	pop	r29
    1e6e:	cf 91       	pop	r28
    1e70:	08 95       	ret

00001e72 <Limpa_Display>:

/* Esta função desliga todos os pixels do display gráfico */
void Limpa_Display(void)
{
    1e72:	cf 93       	push	r28
    1e74:	df 93       	push	r29
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 8 páginas
    1e76:	d0 e0       	ldi	r29, 0x00	; 0
    1e78:	0b c0       	rjmp	.+22     	; 0x1e90 <Limpa_Display+0x1e>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 128 colunas
		    Escreve_Dado(0x00, pagina, coluna);               //escreve o dado
    1e7a:	4c 2f       	mov	r20, r28
    1e7c:	6d 2f       	mov	r22, r29
    1e7e:	80 e0       	ldi	r24, 0x00	; 0
    1e80:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
/* Esta função desliga todos os pixels do display gráfico */
void Limpa_Display(void)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 8 páginas
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 128 colunas
    1e84:	cf 5f       	subi	r28, 0xFF	; 255
    1e86:	01 c0       	rjmp	.+2      	; 0x1e8a <Limpa_Display+0x18>
    1e88:	c0 e0       	ldi	r28, 0x00	; 0
    1e8a:	cc 23       	and	r28, r28
    1e8c:	b4 f7       	brge	.-20     	; 0x1e7a <Limpa_Display+0x8>
}

/* Esta função desliga todos os pixels do display gráfico */
void Limpa_Display(void)
{
	for(unsigned char pagina = 0; pagina < 8; pagina++)       //varre as 8 páginas
    1e8e:	df 5f       	subi	r29, 0xFF	; 255
    1e90:	d8 30       	cpi	r29, 0x08	; 8
    1e92:	d0 f3       	brcs	.-12     	; 0x1e88 <Limpa_Display+0x16>
	{
		for(unsigned char coluna = 0; coluna < 128; coluna++) //varre as 128 colunas
		    Escreve_Dado(0x00, pagina, coluna);               //escreve o dado
	}
}
    1e94:	df 91       	pop	r29
    1e96:	cf 91       	pop	r28
    1e98:	08 95       	ret

00001e9a <Escreve_S_memdados_light>:

/* Esta função escreve uma string com letras claras e fundo escuro da memória de dados */
void Escreve_S_memdados_light(char *string, unsigned char pagina, unsigned char coluna)
{
    1e9a:	ef 92       	push	r14
    1e9c:	ff 92       	push	r15
    1e9e:	0f 93       	push	r16
    1ea0:	1f 93       	push	r17
    1ea2:	cf 93       	push	r28
    1ea4:	df 93       	push	r29
    1ea6:	ec 01       	movw	r28, r24
    1ea8:	e6 2e       	mov	r14, r22
    1eaa:	04 2f       	mov	r16, r20
	while(*string)
    1eac:	2a c0       	rjmp	.+84     	; 0x1f02 <Escreve_S_memdados_light+0x68>
	{
		while(Status_BF());       //aguarda o display estar livre
    1eae:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1eb2:	81 11       	cpse	r24, r1
    1eb4:	fc cf       	rjmp	.-8      	; 0x1eae <Escreve_S_memdados_light+0x14>
    1eb6:	10 e0       	ldi	r17, 0x00	; 0
    1eb8:	19 c0       	rjmp	.+50     	; 0x1eec <Escreve_S_memdados_light+0x52>
		for(unsigned char i = 0; i < 5; i++)
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[*string - 0x20][i])), pagina, coluna++);
    1eba:	ff 24       	eor	r15, r15
    1ebc:	f3 94       	inc	r15
    1ebe:	f0 0e       	add	r15, r16
    1ec0:	88 81       	ld	r24, Y
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	80 97       	sbiw	r24, 0x20	; 32
    1ec6:	fc 01       	movw	r30, r24
    1ec8:	ee 0f       	add	r30, r30
    1eca:	ff 1f       	adc	r31, r31
    1ecc:	ee 0f       	add	r30, r30
    1ece:	ff 1f       	adc	r31, r31
    1ed0:	e8 0f       	add	r30, r24
    1ed2:	f9 1f       	adc	r31, r25
    1ed4:	e1 0f       	add	r30, r17
    1ed6:	f1 1d       	adc	r31, r1
    1ed8:	e8 59       	subi	r30, 0x98	; 152
    1eda:	ff 4f       	sbci	r31, 0xFF	; 255
    1edc:	84 91       	lpm	r24, Z
    1ede:	40 2f       	mov	r20, r16
    1ee0:	6e 2d       	mov	r22, r14
    1ee2:	80 95       	com	r24
    1ee4:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
void Escreve_S_memdados_light(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string)
	{
		while(Status_BF());       //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)
    1ee8:	1f 5f       	subi	r17, 0xFF	; 255
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[*string - 0x20][i])), pagina, coluna++);
    1eea:	0f 2d       	mov	r16, r15
void Escreve_S_memdados_light(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string)
	{
		while(Status_BF());       //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)
    1eec:	15 30       	cpi	r17, 0x05	; 5
    1eee:	28 f3       	brcs	.-54     	; 0x1eba <Escreve_S_memdados_light+0x20>
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[*string - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++);
    1ef0:	11 e0       	ldi	r17, 0x01	; 1
    1ef2:	10 0f       	add	r17, r16
    1ef4:	40 2f       	mov	r20, r16
    1ef6:	6e 2d       	mov	r22, r14
    1ef8:	8f ef       	ldi	r24, 0xFF	; 255
    1efa:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		string++;
    1efe:	21 96       	adiw	r28, 0x01	; 1
	while(*string)
	{
		while(Status_BF());       //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[*string - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++);
    1f00:	01 2f       	mov	r16, r17
}

/* Esta função escreve uma string com letras claras e fundo escuro da memória de dados */
void Escreve_S_memdados_light(char *string, unsigned char pagina, unsigned char coluna)
{
	while(*string)
    1f02:	88 81       	ld	r24, Y
    1f04:	81 11       	cpse	r24, r1
    1f06:	d3 cf       	rjmp	.-90     	; 0x1eae <Escreve_S_memdados_light+0x14>
		for(unsigned char i = 0; i < 5; i++)
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[*string - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++);
		string++;
	}
}
    1f08:	df 91       	pop	r29
    1f0a:	cf 91       	pop	r28
    1f0c:	1f 91       	pop	r17
    1f0e:	0f 91       	pop	r16
    1f10:	ff 90       	pop	r15
    1f12:	ef 90       	pop	r14
    1f14:	08 95       	ret

00001f16 <Escreve_S_memprogm_light>:

/* Esta função escreve uma string com letras claras e fundo escuro da memória de programa */
void Escreve_S_memprogm_light(const char *string, unsigned char pagina, unsigned char coluna)
{
    1f16:	af 92       	push	r10
    1f18:	bf 92       	push	r11
    1f1a:	cf 92       	push	r12
    1f1c:	df 92       	push	r13
    1f1e:	ef 92       	push	r14
    1f20:	0f 93       	push	r16
    1f22:	1f 93       	push	r17
    1f24:	cf 93       	push	r28
    1f26:	8c 01       	movw	r16, r24
    1f28:	c6 2e       	mov	r12, r22
    1f2a:	e4 2e       	mov	r14, r20
	while(pgm_read_byte(string))              //percorre a string enquanto não encontrar '\0'
    1f2c:	2c c0       	rjmp	.+88     	; 0x1f86 <Escreve_S_memprogm_light+0x70>
	{
		while(Status_BF());                   //aguarda o display estar livre
    1f2e:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    1f32:	81 11       	cpse	r24, r1
    1f34:	fc cf       	rjmp	.-8      	; 0x1f2e <Escreve_S_memprogm_light+0x18>
    1f36:	c0 e0       	ldi	r28, 0x00	; 0
    1f38:	1a c0       	rjmp	.+52     	; 0x1f6e <Escreve_S_memprogm_light+0x58>
		for(unsigned char i = 0; i < 5; i++)  //escreve os 5 bytes que formarão o caractere da string
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i])), pagina, coluna++);
    1f3a:	dd 24       	eor	r13, r13
    1f3c:	d3 94       	inc	r13
    1f3e:	de 0c       	add	r13, r14
    1f40:	f5 01       	movw	r30, r10
    1f42:	84 91       	lpm	r24, Z
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	80 97       	sbiw	r24, 0x20	; 32
    1f48:	fc 01       	movw	r30, r24
    1f4a:	ee 0f       	add	r30, r30
    1f4c:	ff 1f       	adc	r31, r31
    1f4e:	ee 0f       	add	r30, r30
    1f50:	ff 1f       	adc	r31, r31
    1f52:	e8 0f       	add	r30, r24
    1f54:	f9 1f       	adc	r31, r25
    1f56:	ec 0f       	add	r30, r28
    1f58:	f1 1d       	adc	r31, r1
    1f5a:	e8 59       	subi	r30, 0x98	; 152
    1f5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f5e:	84 91       	lpm	r24, Z
    1f60:	4e 2d       	mov	r20, r14
    1f62:	6c 2d       	mov	r22, r12
    1f64:	80 95       	com	r24
    1f66:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
void Escreve_S_memprogm_light(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))              //percorre a string enquanto não encontrar '\0'
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //escreve os 5 bytes que formarão o caractere da string
    1f6a:	cf 5f       	subi	r28, 0xFF	; 255
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i])), pagina, coluna++);
    1f6c:	ed 2c       	mov	r14, r13
void Escreve_S_memprogm_light(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))              //percorre a string enquanto não encontrar '\0'
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //escreve os 5 bytes que formarão o caractere da string
    1f6e:	c5 30       	cpi	r28, 0x05	; 5
    1f70:	20 f3       	brcs	.-56     	; 0x1f3a <Escreve_S_memprogm_light+0x24>
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++); //escreve o espaço para o próximo caractere da string
    1f72:	c1 e0       	ldi	r28, 0x01	; 1
    1f74:	ce 0d       	add	r28, r14
    1f76:	4e 2d       	mov	r20, r14
    1f78:	6c 2d       	mov	r22, r12
    1f7a:	8f ef       	ldi	r24, 0xFF	; 255
    1f7c:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		string++;                             //próximo caractere da string
    1f80:	0f 5f       	subi	r16, 0xFF	; 255
    1f82:	1f 4f       	sbci	r17, 0xFF	; 255
	while(pgm_read_byte(string))              //percorre a string enquanto não encontrar '\0'
	{
		while(Status_BF());                   //aguarda o display estar livre
		for(unsigned char i = 0; i < 5; i++)  //escreve os 5 bytes que formarão o caractere da string
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++); //escreve o espaço para o próximo caractere da string
    1f84:	ec 2e       	mov	r14, r28
}

/* Esta função escreve uma string com letras claras e fundo escuro da memória de programa */
void Escreve_S_memprogm_light(const char *string, unsigned char pagina, unsigned char coluna)
{
	while(pgm_read_byte(string))              //percorre a string enquanto não encontrar '\0'
    1f86:	58 01       	movw	r10, r16
    1f88:	f8 01       	movw	r30, r16
    1f8a:	84 91       	lpm	r24, Z
    1f8c:	81 11       	cpse	r24, r1
    1f8e:	cf cf       	rjmp	.-98     	; 0x1f2e <Escreve_S_memprogm_light+0x18>
		for(unsigned char i = 0; i < 5; i++)  //escreve os 5 bytes que formarão o caractere da string
		    Escreve_Dado(~(pgm_read_byte(&tabela_ASCII[pgm_read_byte(string) - 0x20][i])), pagina, coluna++);
		Escreve_Dado(0xFF, pagina, coluna++); //escreve o espaço para o próximo caractere da string
		string++;                             //próximo caractere da string
	}
}
    1f90:	cf 91       	pop	r28
    1f92:	1f 91       	pop	r17
    1f94:	0f 91       	pop	r16
    1f96:	ef 90       	pop	r14
    1f98:	df 90       	pop	r13
    1f9a:	cf 90       	pop	r12
    1f9c:	bf 90       	pop	r11
    1f9e:	af 90       	pop	r10
    1fa0:	08 95       	ret

00001fa2 <main>:
const char teste_memprog[] PROGMEM = "Teste!\0";
const char str_memprog[] PROGMEM = "memoria de programa!\0";

int main() //função principal
{
	DDRD = 0xFF;   //configura todo o PORTD como saída
    1fa2:	8f ef       	ldi	r24, 0xFF	; 255
    1fa4:	8a b9       	out	0x0a, r24	; 10
	DDRB = 0xFF;   //configura todo o PORTB como saída
    1fa6:	84 b9       	out	0x04, r24	; 4
	DDRC = 0xFF;   //configura todo o PORTC como saída
    1fa8:	87 b9       	out	0x07, r24	; 7
	UCSR0B = 0x00; //configura os pinos PD0 e PD1 como I/Os desabilitando as funções de RX e TX
    1faa:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>

	Inicializacao_Display(); //Inicializa o display gráfico
    1fae:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <Inicializacao_Display>
	Testa_Display();         //liga todos os pixels do display
    1fb2:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <Testa_Display>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1fb6:	2f ef       	ldi	r18, 0xFF	; 255
    1fb8:	89 e6       	ldi	r24, 0x69	; 105
    1fba:	98 e1       	ldi	r25, 0x18	; 24
    1fbc:	21 50       	subi	r18, 0x01	; 1
    1fbe:	80 40       	sbci	r24, 0x00	; 0
    1fc0:	90 40       	sbci	r25, 0x00	; 0
    1fc2:	e1 f7       	brne	.-8      	; 0x1fbc <main+0x1a>
    1fc4:	00 c0       	rjmp	.+0      	; 0x1fc6 <main+0x24>
    1fc6:	00 00       	nop
	_delay_ms(500);
	Limpa_Display();         //limpa a tela do display
    1fc8:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <Limpa_Display>
    1fcc:	2f ef       	ldi	r18, 0xFF	; 255
    1fce:	89 e6       	ldi	r24, 0x69	; 105
    1fd0:	98 e1       	ldi	r25, 0x18	; 24
    1fd2:	21 50       	subi	r18, 0x01	; 1
    1fd4:	80 40       	sbci	r24, 0x00	; 0
    1fd6:	90 40       	sbci	r25, 0x00	; 0
    1fd8:	e1 f7       	brne	.-8      	; 0x1fd2 <main+0x30>
    1fda:	00 c0       	rjmp	.+0      	; 0x1fdc <main+0x3a>
    1fdc:	00 00       	nop
	_delay_ms(500);
	Escreve_S_memdados("Display pronto", 0, 0); //exibe uma mensagem
    1fde:	40 e0       	ldi	r20, 0x00	; 0
    1fe0:	60 e0       	ldi	r22, 0x00	; 0
    1fe2:	80 e0       	ldi	r24, 0x00	; 0
    1fe4:	91 e0       	ldi	r25, 0x01	; 1
    1fe6:	0e 94 86 0e 	call	0x1d0c	; 0x1d0c <Escreve_S_memdados>
	Escreve_S_memdados("Teste!", 1, 0);
    1fea:	40 e0       	ldi	r20, 0x00	; 0
    1fec:	61 e0       	ldi	r22, 0x01	; 1
    1fee:	8f e0       	ldi	r24, 0x0F	; 15
    1ff0:	91 e0       	ldi	r25, 0x01	; 1
    1ff2:	0e 94 86 0e 	call	0x1d0c	; 0x1d0c <Escreve_S_memdados>
	Escreve_S_memprogm(teste_memprog, 2, 0);
    1ff6:	40 e0       	ldi	r20, 0x00	; 0
    1ff8:	62 e0       	ldi	r22, 0x02	; 2
    1ffa:	89 e5       	ldi	r24, 0x59	; 89
    1ffc:	92 e0       	ldi	r25, 0x02	; 2
    1ffe:	0e 94 c3 0e 	call	0x1d86	; 0x1d86 <Escreve_S_memprogm>
    2002:	2f ef       	ldi	r18, 0xFF	; 255
    2004:	83 ed       	ldi	r24, 0xD3	; 211
    2006:	90 e3       	ldi	r25, 0x30	; 48
    2008:	21 50       	subi	r18, 0x01	; 1
    200a:	80 40       	sbci	r24, 0x00	; 0
    200c:	90 40       	sbci	r25, 0x00	; 0
    200e:	e1 f7       	brne	.-8      	; 0x2008 <main+0x66>
    2010:	00 c0       	rjmp	.+0      	; 0x2012 <main+0x70>
    2012:	00 00       	nop
	_delay_ms(1000);

	while(1) //loop infinito
	{
		for(unsigned char frame = 0; frame < 6; frame++)         //percorre o ponteiro que aponta para os vetores que contém as imagens
    2014:	c0 e0       	ldi	r28, 0x00	; 0
    2016:	11 c0       	rjmp	.+34     	; 0x203a <main+0x98>
		{
			Imprime_Imagem((PGM_P)pgm_read_word(&p_ryu[frame])); //imprime a imagem 'frame' na tela do display gráfico
    2018:	ec 2f       	mov	r30, r28
    201a:	f0 e0       	ldi	r31, 0x00	; 0
    201c:	ee 0f       	add	r30, r30
    201e:	ff 1f       	adc	r31, r31
    2020:	ef 59       	subi	r30, 0x9F	; 159
    2022:	fd 4f       	sbci	r31, 0xFD	; 253
    2024:	85 91       	lpm	r24, Z+
    2026:	94 91       	lpm	r25, Z
    2028:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <Imprime_Imagem>
    202c:	8f ed       	ldi	r24, 0xDF	; 223
    202e:	9e e2       	ldi	r25, 0x2E	; 46
    2030:	01 97       	sbiw	r24, 0x01	; 1
    2032:	f1 f7       	brne	.-4      	; 0x2030 <main+0x8e>
    2034:	00 c0       	rjmp	.+0      	; 0x2036 <main+0x94>
    2036:	00 00       	nop
	Escreve_S_memprogm(teste_memprog, 2, 0);
	_delay_ms(1000);

	while(1) //loop infinito
	{
		for(unsigned char frame = 0; frame < 6; frame++)         //percorre o ponteiro que aponta para os vetores que contém as imagens
    2038:	cf 5f       	subi	r28, 0xFF	; 255
    203a:	c6 30       	cpi	r28, 0x06	; 6
    203c:	68 f3       	brcs	.-38     	; 0x2018 <main+0x76>
			Imprime_Imagem((PGM_P)pgm_read_word(&p_ryu[frame])); //imprime a imagem 'frame' na tela do display gráfico
			_delay_ms(3);                                        //delay de 3ms para o efeito de persistência da visão
		}
		
		char dado_lido;	                          //variável para ler um byte	
		while(Status_BF());                       //aguarda o display estar livre
    203e:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    2042:	81 11       	cpse	r24, r1
    2044:	fc cf       	rjmp	.-8      	; 0x203e <main+0x9c>
		Limpa_Display();                          //limpa a tela do display
    2046:	0e 94 39 0f 	call	0x1e72	; 0x1e72 <Limpa_Display>
		while(Status_BF());                       //aguarda o display estar livre
    204a:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    204e:	81 11       	cpse	r24, r1
    2050:	fc cf       	rjmp	.-8      	; 0x204a <main+0xa8>
		Escreve_Dado(0xFF, 0x00, 0x00);           //escreve '0xFF' na coluna 0 da página 0
    2052:	40 e0       	ldi	r20, 0x00	; 0
    2054:	60 e0       	ldi	r22, 0x00	; 0
    2056:	8f ef       	ldi	r24, 0xFF	; 255
    2058:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		for(unsigned char i = 0; i < 7; i++)      //lê o byte das colunas 0 até 6
    205c:	c0 e0       	ldi	r28, 0x00	; 0
    205e:	13 c0       	rjmp	.+38     	; 0x2086 <main+0xe4>
		{		
		    while(Status_BF());                   //aguarda o display estar livre
    2060:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    2064:	81 11       	cpse	r24, r1
    2066:	fc cf       	rjmp	.-8      	; 0x2060 <main+0xbe>
		    dado_lido = Leitura_Dado(0x00, i);    //lê o byte da coluna 'i' da página 0
    2068:	6c 2f       	mov	r22, r28
    206a:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <Leitura_Dado>
		    dado_lido = dado_lido << 1;           //desloca o byte um bit para a esquerda
    206e:	d8 2f       	mov	r29, r24
    2070:	dd 0f       	add	r29, r29
		    while(Status_BF());                   //aguarda o display estar livre
    2072:	0e 94 a8 0d 	call	0x1b50	; 0x1b50 <Status_BF>
    2076:	81 11       	cpse	r24, r1
    2078:	fc cf       	rjmp	.-8      	; 0x2072 <main+0xd0>
		    Escreve_Dado(dado_lido, 0x00, i + 1); //ecreve o byte lido em 'i' em 'i + 1'
    207a:	cf 5f       	subi	r28, 0xFF	; 255
    207c:	4c 2f       	mov	r20, r28
    207e:	60 e0       	ldi	r22, 0x00	; 0
    2080:	8d 2f       	mov	r24, r29
    2082:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <Escreve_Dado>
		char dado_lido;	                          //variável para ler um byte	
		while(Status_BF());                       //aguarda o display estar livre
		Limpa_Display();                          //limpa a tela do display
		while(Status_BF());                       //aguarda o display estar livre
		Escreve_Dado(0xFF, 0x00, 0x00);           //escreve '0xFF' na coluna 0 da página 0
		for(unsigned char i = 0; i < 7; i++)      //lê o byte das colunas 0 até 6
    2086:	c7 30       	cpi	r28, 0x07	; 7
    2088:	58 f3       	brcs	.-42     	; 0x2060 <main+0xbe>
		    dado_lido = dado_lido << 1;           //desloca o byte um bit para a esquerda
		    while(Status_BF());                   //aguarda o display estar livre
		    Escreve_Dado(dado_lido, 0x00, i + 1); //ecreve o byte lido em 'i' em 'i + 1'
	    }
		
		Testa_Display();
    208a:	0e 94 25 0f 	call	0x1e4a	; 0x1e4a <Testa_Display>
		Escreve_S_memdados_light("memoria de dados!", 0x00, 0x00);
    208e:	40 e0       	ldi	r20, 0x00	; 0
    2090:	60 e0       	ldi	r22, 0x00	; 0
    2092:	86 e1       	ldi	r24, 0x16	; 22
    2094:	91 e0       	ldi	r25, 0x01	; 1
    2096:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <Escreve_S_memdados_light>
		Escreve_S_memprogm_light(str_memprog, 0x01, 0x00);
    209a:	40 e0       	ldi	r20, 0x00	; 0
    209c:	61 e0       	ldi	r22, 0x01	; 1
    209e:	83 e4       	ldi	r24, 0x43	; 67
    20a0:	92 e0       	ldi	r25, 0x02	; 2
    20a2:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <Escreve_S_memprogm_light>
    20a6:	ff cf       	rjmp	.-2      	; 0x20a6 <main+0x104>

000020a8 <_exit>:
    20a8:	f8 94       	cli

000020aa <__stop_program>:
    20aa:	ff cf       	rjmp	.-2      	; 0x20aa <__stop_program>
